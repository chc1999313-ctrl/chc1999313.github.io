<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>èµ›åšé‡‘è‰²åœ£è¯æ ‘ (æ‰‹åŠ¿ç‰ˆ)</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; 
        }
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }
        .btn {
            pointer-events: auto;
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            border: 1px solid #ffd700;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 5px;
            transition: 0.3s;
        }
        .btn:active, .btn.active {
            background: #ffd700;
            color: #000;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }
        #file-input { display: none; }
        
        /* æ‘„åƒå¤´é¢„è§ˆçª—å£ (å¯é€‰æ˜¾ç¤ºï¼Œé»˜è®¤éšè—æˆ–è€…æ”¾è§’è½) */
        #camera-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 75px;
            border-radius: 8px;
            z-index: 90;
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.7;
            border: 1px solid #ffd700;
            display: none; /* ç‚¹å‡»å¼€å¯åæ˜¾ç¤º */
        }

        .status-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 215, 0, 0.7);
            font-size: 12px;
            pointer-events: none;
            line-height: 1.5;
            text-shadow: 0 0 5px #000;
        }
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            display: none;
        }
    </style>
</head>
<body>

    <div class="status-text" id="status">
        âœ¨ æ¨¡å¼: è§¦å±/é¼ æ ‡<br>
        ğŸ“· ç‚¹å‡»ä¸‹æ–¹"å¼€å¯æ‘„åƒå¤´"å¯ç”¨æ‰‹åŠ¿<br>
        ğŸ– å¼ æ‰‹/ğŸ‘Œæåˆ: å˜æ˜Ÿçƒ | â˜ï¸æŒ‡å¤©: é€‰ç…§ç‰‡
    </div>

    <div id="loading" class="loading">æ­£åœ¨åŠ è½½ AI æ¨¡å‹...</div>
    
    <video id="camera-preview" playsinline muted autoplay></video>

    <div id="ui-container">
        <input type="file" id="file-input" accept="image/*">
        <button class="btn" id="cam-btn" onclick="toggleCamera()">ğŸ“· å¼€å¯æ‘„åƒå¤´æ§åˆ¶</button>
        <button class="btn" onclick="document.getElementById('file-input').click()">ğŸ–¼ï¸ æ·»åŠ ç…§ç‰‡</button>
    </div>

    <!-- æ ¸å¿ƒåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- MediaPipe æ‰‹åŠ¿è¯†åˆ«åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. åŸºç¡€åœºæ™¯å˜é‡ ---
        let scene, camera, renderer, controls;
        let particles, particleGeo;
        let ringGroup; // è£…é¥°ç¯
        let photoGroup; // ç…§ç‰‡ç»„
        let isPlanet = false; // å½“å‰çŠ¶æ€ï¼šæ ‘ è¿˜æ˜¯ æ˜Ÿçƒ
        let clock = new THREE.Clock();

        // ç²’å­æ•°æ®
        const particleCount = 2000; // ç²’å­æ•°é‡
        const positionsTree = []; // æ ‘å½¢æ€åæ ‡
        const positionsPlanet = []; // æ˜Ÿçƒå½¢æ€åæ ‡
        const currentPositions = []; // å½“å‰åæ ‡

        // --- 2. æ‘„åƒå¤´ä¸æ‰‹åŠ¿å˜é‡ ---
        let hands;
        let cameraVideoElement;
        let isCameraActive = false;
        let lastPhotoTriggerTime = 0; // é˜²æ­¢æ‰‹åŠ¿é‡å¤è§¦å‘

        initThree();
        animate();

        // --- Three.js åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene();
            // é»‘è‰²èƒŒæ™¯ + è¿œå¤„çš„é‡‘è‰²é›¾æ°”
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            // é‡‘è‰²ç‚¹å…‰æº
            const pLight = new THREE.PointLight(0xffd700, 1.5, 50);
            pLight.position.set(5, 5, 5);
            scene.add(pLight);
            
            // è“è‰²èƒŒå…‰ (å¢åŠ èµ›åšæ„Ÿ)
            const bLight = new THREE.PointLight(0x0088ff, 1, 50);
            bLight.position.set(-5, -5, -5);
            scene.add(bLight);

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticles();
            
            // åˆ›å»ºè£…é¥°ç¯
            createRings();

            // ç…§ç‰‡ç»„
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // ç›‘å¬çª—å£
            window.addEventListener('resize', onWindowResize, false);
            // ç›‘å¬ä¸Šä¼ 
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
        }

        // --- ç”Ÿæˆç²’å­ä¸å½¢æ€æ•°æ® ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const colors = [];
            const sizes = [];

            const treeHeight = 16;
            const treeRadius = 6;
            const planetRadius = 7;

            for (let i = 0; i < particleCount; i++) {
                // 1. è®¡ç®—ã€åœ£è¯æ ‘ã€‘å½¢æ€åæ ‡ (èºæ—‹åœ†é”¥)
                const t = i / particleCount;
                const angle = t * 25; // èºæ—‹åœˆæ•°
                const radius = (1 - t) * treeRadius; 
                const x1 = Math.cos(angle) * radius + (Math.random()-0.5);
                const y1 = (t * treeHeight) - treeHeight/2;
                const z1 = Math.sin(angle) * radius + (Math.random()-0.5);
                
                positionsTree.push(x1, y1, z1);

                // 2. è®¡ç®—ã€æ˜Ÿçƒã€‘å½¢æ€åæ ‡ (çƒä½“)
                const phi = Math.acos(-1 + (2 * i) / particleCount);
                const theta = Math.sqrt(particleCount * Math.PI) * phi;
                const x2 = planetRadius * Math.cos(theta) * Math.sin(phi);
                const y2 = planetRadius * Math.sin(theta) * Math.sin(phi);
                const z2 = planetRadius * Math.cos(phi);

                positionsPlanet.push(x2, y2, z2);

                // 3. åˆå§‹åŒ–å½“å‰åæ ‡ (é»˜è®¤æ˜¯æ ‘)
                currentPositions.push(x1, y1, z1);

                // é¢œè‰² (é‡‘è‰²ç³»: é‡‘é»„ã€ç™½ã€æ©™)
                const colorType = Math.random();
                let c = new THREE.Color();
                if(colorType > 0.8) c.setHex(0xffffff); // ç™½é—ªçƒ
                else if (colorType > 0.3) c.setHex(0xffd700); // çº¯é‡‘
                else c.setHex(0xffaa00); // æ·±é‡‘/æ©™
                
                colors.push(c.r, c.g, c.b);
                sizes.push(Math.random() * 0.5 + 0.1);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPositions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // æè´¨
            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                map: createSparkleTexture(),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createRings() {
            ringGroup = new THREE.Group();
            scene.add(ringGroup);

            // åˆ›å»ºå‡ ä¸ªé‡‘è‰²å…‰ç¯
            const createRing = (r, tiltX, tiltZ) => {
                const geo = new THREE.TorusGeometry(r, 0.05, 16, 100);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.4 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = tiltX;
                mesh.rotation.z = tiltZ;
                ringGroup.add(mesh);
                return mesh;
            };

            createRing(7.5, 1.5, 0.2);
            createRing(6.0, 2.0, -0.4);
            createRing(8.5, 1.0, 0.5);
        }

        // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (MediaPipe) ---
        async function toggleCamera() {
            if(isCameraActive) return;
            const btn = document.getElementById('cam-btn');
            const status = document.getElementById('status');
            const preview = document.getElementById('camera-preview');
            const loading = document.getElementById('loading');

            loading.style.display = 'block';
            status.innerHTML = "æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´ï¼Œè¯·ç¨å€™...<br>(æ‰‹æœºç«¯è¯·ç¡®ä¿ä½¿ç”¨HTTPSåè®®)";

            try {
                cameraVideoElement = document.getElementById('camera-preview');
                
                hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onHandsResults);

                // ä½¿ç”¨ CameraUtils å·¥å…·ç±»
                const cameraUtils = new Camera(cameraVideoElement, {
                    onFrame: async () => {
                        await hands.send({image: cameraVideoElement});
                    },
                    width: 640,
                    height: 480
                });

                await cameraUtils.start();

                isCameraActive = true;
                loading.style.display = 'none';
                preview.style.display = 'block';
                btn.classList.add('active');
                btn.innerText = "ğŸ”µ æ‘„åƒå¤´è¿è¡Œä¸­";
                status.innerHTML = "âœ‹ æ‘„åƒå¤´å·²æ¥ç®¡!<br>ğŸ– å¼ æ‰‹/ğŸ‘Œæåˆ: å˜èº«æ˜Ÿçƒ<br>â˜ï¸ é£ŸæŒ‡å‘ä¸Š: æ·»åŠ ç…§ç‰‡";

            } catch (error) {
                console.error(error);
                loading.style.display = 'none';
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼\nè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™ï¼Œæˆ–ç¡®è®¤é“¾æ¥æ˜¯HTTPSå¼€å¤´ã€‚");
                status.innerHTML = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥";
            }
        }

        function onHandsResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                // æ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œæ…¢æ…¢å˜å›æ ‘
                isPlanet = false;
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            
            // ç®€å•çš„æ‰‹åŠ¿é€»è¾‘åˆ¤æ–­
            
            // 1. åˆ¤æ–­æ˜¯å¦å¼ å¼€æ‰‹ (æ£€æµ‹æŒ‡å°–å’ŒæŒ‡æ ¹è·ç¦»)
            // æ‹‡æŒ‡(4), é£ŸæŒ‡(8), ä¸­æŒ‡(12), æ— åæŒ‡(16), å°æŒ‡(20)
            const isThumbOpen = landmarks[4].x < landmarks[3].x; // ç®€åŒ–åˆ¤æ–­
            const isIndexOpen = landmarks[8].y < landmarks[6].y;
            const isMiddleOpen = landmarks[12].y < landmarks[10].y;
            const isRingOpen = landmarks[16].y < landmarks[14].y;
            const isPinkyOpen = landmarks[20].y < landmarks[18].y;

            const openFingersCount = [isIndexOpen, isMiddleOpen, isRingOpen, isPinkyOpen].filter(Boolean).length;

            // 2. æ£€æµ‹ "é£ŸæŒ‡æŒ‡å¤©" (åªæœ‰é£ŸæŒ‡ä¼¸å‡º) -> è§¦å‘ç…§ç‰‡
            if (isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) {
                const now = Date.now();
                if (now - lastPhotoTriggerTime > 2000) { // 2ç§’é˜²æŠ–
                    lastPhotoTriggerTime = now;
                    // è§†è§‰åé¦ˆ
                    const status = document.getElementById('status');
                    const originalText = status.innerHTML;
                    status.style.color = "#fff";
                    status.innerHTML = "ğŸ“¸ è¯†åˆ«åˆ°æŒ‡ä»¤ï¼šæ·»åŠ ç…§ç‰‡ï¼";
                    setTimeout(() => { 
                        document.getElementById('file-input').click(); 
                        status.style.color = "rgba(255, 215, 0, 0.7)";
                        status.innerHTML = originalText;
                    }, 500);
                }
            }
            
            // 3. æ£€æµ‹ "å¼ å¼€æ‰‹" æˆ– "åŒæŒ‡æåˆ" -> å˜æ˜Ÿçƒ
            // è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const pinchDist = Math.sqrt(dx*dx + dy*dy);
            const isPinching = pinchDist < 0.05;

            if (openFingersCount >= 3 || isPinching) {
                isPlanet = true;
            } else {
                isPlanet = false;
            }
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            controls.update();

            // 1. ç²’å­å˜å½¢é€»è¾‘ (Lerp æ’å€¼)
            const positions = particles.geometry.attributes.position.array;
            // å†³å®šç›®æ ‡åæ ‡æ•°ç»„
            const targetPositions = isPlanet ? positionsPlanet : positionsTree;
            
            // å˜å½¢é€Ÿåº¦ (è¶Šå¤§çº¦å¿«)
            const morphSpeed = 0.05;

            for(let i = 0; i < particleCount; i++) {
                const px = positions[i*3];
                const py = positions[i*3+1];
                const pz = positions[i*3+2];
                
                const tx = targetPositions[i*3];
                const ty = targetPositions[i*3+1];
                const tz = targetPositions[i*3+2];

                // ç®€å•çš„å¹³æ»‘ç§»åŠ¨ç®—æ³•
                positions[i*3]   += (tx - px) * morphSpeed;
                positions[i*3+1] += (ty - py) * morphSpeed;
                positions[i*3+2] += (tz - pz) * morphSpeed;
                
                // å¦‚æœæ˜¯æ ‘å½¢æ€ï¼Œè®©ç²’å­æœ‰ä¸ªè½»å¾®çš„ä¸Šä¸‹æµ®åŠ¨ï¼Œæ¨¡æ‹Ÿå‘¼å¸
                if(!isPlanet) {
                    positions[i*3+1] += Math.sin(time * 2 + px) * 0.01;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 2. è£…é¥°ç¯åŠ¨ç”»
            if(ringGroup) {
                ringGroup.rotation.y += 0.005;
                ringGroup.rotation.x = Math.sin(time * 0.5) * 0.2;
                // å¦‚æœæ˜¯æ˜Ÿçƒæ¨¡å¼ï¼Œç¯æ”¾å¤§
                const targetScale = isPlanet ? 1.5 : 1;
                ringGroup.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.05);
            }

            // 3. ç…§ç‰‡è·Ÿéšå˜å½¢
            updatePhotos(isPlanet);

            renderer.render(scene, camera);
        }

        // --- è¾…åŠ©åŠŸèƒ½ ---

        // å¤„ç†ç…§ç‰‡ä¸Šä¼ 
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.src = e.target.result;
                img.onload = () => addPhoto(img);
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function addPhoto(image) {
            const texture = new THREE.Texture(image);
            texture.needsUpdate = true;
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const ratio = image.width / image.height;
            const geo = new THREE.PlaneGeometry(1.5 * ratio, 1.5);
            const mesh = new THREE.Mesh(geo, mat);

            // ç»™ç…§ç‰‡æ·»åŠ é‡‘è‰²è¾¹æ¡†
            const borderGeo = new THREE.PlaneGeometry(1.5 * ratio + 0.1, 1.5 + 0.1);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.01;
            mesh.add(border);

            // éšæœºåˆ†é…ä¸¤ä¸ªä½ç½®ï¼šæ ‘çš„ä½ç½® å’Œ æ˜Ÿçƒçš„ä½ç½®
            // æ ‘ä½ç½®
            const tAngle = Math.random() * Math.PI * 2;
            const tY = (Math.random() * 12) - 6;
            const tR = (1 - (tY + 8)/16) * 6 + 1; // ç®€åŒ–çš„åœ†é”¥åŠå¾„
            const tPos = new THREE.Vector3(Math.cos(tAngle)*tR, tY, Math.sin(tAngle)*tR);

            // æ˜Ÿçƒä½ç½® (çƒé¢)
            const pVec = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(7.2);

            // å­˜å‚¨åœ¨ userData é‡Œæ–¹ä¾¿åŠ¨ç”»æ›´æ–°
            mesh.userData = {
                treePos: tPos,
                planetPos: pVec,
                lookAtCenter: true
            };
            
            // åˆå§‹è®¾ä¸ºå½“å‰çŠ¶æ€ä½ç½®
            mesh.position.copy(isPlanet ? pVec : tPos);
            mesh.lookAt(0, mesh.position.y, 0);

            photoGroup.add(mesh);
        }

        function updatePhotos(isTargetPlanet) {
            photoGroup.children.forEach(mesh => {
                const target = isTargetPlanet ? mesh.userData.planetPos : mesh.userData.treePos;
                
                // ä½ç½®å¹³æ»‘è¿‡æ¸¡
                mesh.position.lerp(target, 0.05);

                // æœå‘å¤„ç†ï¼šå§‹ç»ˆèƒŒå¯¹åœ†å¿ƒ(å³é¢å‘å¤–éƒ¨)
                // ç®€å•çš„ LookAt(0,0,0) ä¼šè®©èƒŒé¢æœå¤–ï¼Œæ‰€ä»¥æˆ‘ä»¬ LookAt åå†è½¬ 180åº¦
                mesh.lookAt(0, isTargetPlanet ? 0 : mesh.position.y, 0); 
                mesh.rotateY(Math.PI);
            });
        }

        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.4, 'rgba(255, 215, 0, 0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.Texture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>